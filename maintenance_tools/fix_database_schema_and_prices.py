#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
üîß CORRECCI√ìN COMPLETA DE ESQUEMA Y PRECIOS
==========================================

Script que:
1. üóÑÔ∏è Adapta al esquema real de la base de datos
2. üí∏ Corrige precios inv√°lidos sin campos inexistentes
3. üõ°Ô∏è Implementa constraints que funcionen con el esquema actual
4. üì¶ Guarda datos inv√°lidos en Parquet para auditor√≠a

Autor: Sistema V5 Production
Fecha: 04/09/2025
"""

import os
import sys
import psycopg2
import psycopg2.extras
import pandas as pd
from datetime import datetime
from pathlib import Path
import json
from typing import Dict, List, Any, Optional

# Configurar soporte completo de emojis
sys.path.append(str(Path(__file__).parent))
from portable_orchestrator_v5.core.emoji_support import force_emoji_support
force_emoji_support()

# Cargar configuraci√≥n
from dotenv import load_dotenv
load_dotenv()

class DatabaseSchemaFixer:
    """üîß Corrector completo de esquema y precios"""
    
    def __init__(self):
        """Inicializar corrector"""
        print("üîß Inicializando Corrector de Esquema y Precios...")
        
        # Par√°metros de conexi√≥n PostgreSQL
        self.conn_params = {
            'host': os.getenv('PGHOST', 'localhost'),
            'port': int(os.getenv('PGPORT', '5432')),
            'database': os.getenv('PGDATABASE', 'orchestrator'),
            'user': os.getenv('PGUSER', 'postgres'),
            'password': os.getenv('PGPASSWORD', 'postgres')
        }
        
        try:
            self.conn = psycopg2.connect(**self.conn_params)
            self.conn.autocommit = True
            self.cursor = self.conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
            print(f"‚úÖ Conectado a PostgreSQL: {self.conn_params['host']}:{self.conn_params['port']}")
        except Exception as e:
            print(f"‚ùå Error conectando a PostgreSQL: {e}")
            raise
        
        # Configurar directorios
        self.parquet_dir = Path("data/invalid_prices_parquet")
        self.parquet_dir.mkdir(parents=True, exist_ok=True)
        
        # Estad√≠sticas
        self.stats = {
            'schema_analyzed': False,
            'invalid_prices_found': 0,
            'prices_corrected': 0,
            'constraints_added': 0,
            'records_backed_up': 0
        }
        
        # Esquema real de la base de datos
        self.real_schema = {}
    
    def analyze_real_database_schema(self):
        """üîç Analizar esquema real de la base de datos"""
        print("\n" + "üîç" + "="*80 + "üîç")
        print("üîç ANALIZANDO ESQUEMA REAL DE LA BASE DE DATOS")
        print("üîç" + "="*80 + "üîç")
        
        # Analizar tabla master_productos
        self.cursor.execute("""
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns
            WHERE table_name = 'master_productos'
            ORDER BY ordinal_position
        """)
        
        productos_columns = self.cursor.fetchall()
        
        print("üìä TABLA master_productos:")
        for col in productos_columns:
            nullable = "NULL" if col['is_nullable'] == 'YES' else "NOT NULL"
            print(f"   üìù {col['column_name']}: {col['data_type']} ({nullable})")
        
        # Analizar tabla master_precios
        self.cursor.execute("""
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns
            WHERE table_name = 'master_precios'
            ORDER BY ordinal_position
        """)
        
        precios_columns = self.cursor.fetchall()
        
        print("\nüí∞ TABLA master_precios:")
        for col in precios_columns:
            nullable = "NULL" if col['is_nullable'] == 'YES' else "NOT NULL"
            print(f"   üí∏ {col['column_name']}: {col['data_type']} ({nullable})")
        
        # Guardar esquema real
        self.real_schema = {
            'master_productos': {col['column_name']: col for col in productos_columns},
            'master_precios': {col['column_name']: col for col in precios_columns}
        }
        
        self.stats['schema_analyzed'] = True
        
        # Verificar campos cr√≠ticos
        precios_fields = [col['column_name'] for col in precios_columns]
        
        critical_fields = ['precio_normal', 'precio_oferta', 'precio_tarjeta']
        missing_fields = [field for field in critical_fields if field not in precios_fields]
        
        if missing_fields:
            print(f"\n‚ö†Ô∏è CAMPOS CR√çTICOS FALTANTES: {', '.join(missing_fields)}")
        else:
            print(f"\n‚úÖ Todos los campos cr√≠ticos presentes")
            
        return self.real_schema
    
    def backup_invalid_prices_to_parquet_simple(self):
        """üì¶ Backup simplificado sin campos inexistentes"""
        print("\n" + "üì¶" + "="*80 + "üì¶")
        print("üì¶ RESPALDANDO PRECIOS INV√ÅLIDOS (ESQUEMA ADAPTADO)")
        print("üì¶" + "="*80 + "üì¶")
        
        # Query adaptada al esquema real
        query = """
            SELECT 
                p.codigo_interno,
                p.nombre,
                p.retailer,
                p.marca,
                p.categoria,
                p.link,
                pr.fecha,
                pr.precio_normal,
                pr.precio_oferta,
                pr.precio_tarjeta,
                pr.timestamp_creacion,
                pr.cambio_porcentaje,
                (pr.precio_oferta - pr.precio_normal) as diferencia_oferta,
                ((pr.precio_oferta - pr.precio_normal)::DECIMAL / pr.precio_normal * 100) as porcentaje_incremento,
                NOW() as backup_timestamp,
                'invalid_offer_price' as issue_type
            FROM master_productos p
            JOIN master_precios pr ON p.codigo_interno = pr.codigo_interno
            WHERE pr.precio_oferta > pr.precio_normal
            AND pr.precio_oferta IS NOT NULL
            AND pr.precio_normal IS NOT NULL
            ORDER BY porcentaje_incremento DESC
        """
        
        self.cursor.execute(query)
        invalid_records = self.cursor.fetchall()
        
        if not invalid_records:
            print("‚úÖ No se encontraron precios inv√°lidos para respaldar")
            return None
        
        print(f"üîç Encontrados {len(invalid_records)} precios inv√°lidos")
        
        # Convertir a DataFrame
        df = pd.DataFrame([dict(record) for record in invalid_records])
        
        # Mostrar estad√≠sticas
        print(f"üìä ESTAD√çSTICAS DE PRECIOS INV√ÅLIDOS:")
        print(f"   üì¶ Total registros: {len(df)}")
        print(f"   üè™ Retailers afectados: {df['retailer'].nunique()}")
        print(f"   üí∞ Diferencia promedio: ${df['diferencia_oferta'].mean():,.0f}")
        print(f"   üìà Incremento promedio: {df['porcentaje_incremento'].mean():.1f}%")
        
        # Mostrar casos extremos
        print(f"\nüî• TOP 5 CASOS M√ÅS EXTREMOS:")
        top_cases = df.nlargest(5, 'porcentaje_incremento')
        for idx, case in top_cases.iterrows():
            print(f"   {idx+1}. {case['nombre'][:50]}...")
            print(f"      üí∞ ${case['precio_normal']:,.0f} ‚Üí ${case['precio_oferta']:,.0f} ({case['porcentaje_incremento']:.1f}%)")
            print(f"      üè™ {case['retailer']}")
        
        # Guardar en Parquet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        parquet_file = self.parquet_dir / f"invalid_prices_backup_{timestamp}.parquet"
        
        try:
            df.to_parquet(parquet_file, compression='snappy', index=False)
            file_size_mb = parquet_file.stat().st_size / (1024 * 1024)
            
            print(f"\nüíæ BACKUP PARQUET CREADO:")
            print(f"   üìÑ Archivo: {parquet_file}")
            print(f"   üìä Tama√±o: {file_size_mb:.2f} MB")
            
            self.stats['records_backed_up'] = len(df)
            self.stats['invalid_prices_found'] = len(df)
            
            return parquet_file
            
        except Exception as e:
            print(f"‚ùå Error creando backup Parquet: {e}")
            
            # Fallback a CSV
            csv_file = self.parquet_dir / f"invalid_prices_backup_{timestamp}.csv"
            df.to_csv(csv_file, index=False, encoding='utf-8')
            print(f"üíæ Backup guardado como CSV: {csv_file}")
            
            return csv_file
    
    def correct_invalid_prices_simple(self):
        """üí∏ Correcci√≥n simple de precios inv√°lidos"""
        print("\n" + "üí∏" + "="*80 + "üí∏")
        print("üí∏ CORRIGIENDO PRECIOS INV√ÅLIDOS (M√âTODO SIMPLE)")
        print("üí∏" + "="*80 + "üí∏")
        
        # Contar precios inv√°lidos
        self.cursor.execute("""
            SELECT COUNT(*) as count
            FROM master_precios 
            WHERE precio_oferta > precio_normal 
            AND precio_oferta IS NOT NULL
            AND precio_normal IS NOT NULL
        """)
        
        invalid_count = self.cursor.fetchone()['count']
        
        if invalid_count == 0:
            print("‚úÖ No hay precios inv√°lidos para corregir")
            return
        
        print(f"üîç Encontrados {invalid_count} precios inv√°lidos a corregir")
        
        # M√©todo simple usando variables temporales
        correction_sql = """
            UPDATE master_precios 
            SET precio_normal = precio_oferta, 
                precio_oferta = precio_normal
            WHERE precio_oferta > precio_normal 
            AND precio_oferta IS NOT NULL
            AND precio_normal IS NOT NULL;
        """
        
        # Usar una funci√≥n temporal m√°s simple
        simple_correction_sql = """
            WITH price_swaps AS (
                SELECT codigo_interno, fecha,
                       precio_normal as old_normal,
                       precio_oferta as old_oferta
                FROM master_precios 
                WHERE precio_oferta > precio_normal 
                AND precio_oferta IS NOT NULL
                AND precio_normal IS NOT NULL
            )
            UPDATE master_precios mp
            SET precio_normal = ps.old_oferta,
                precio_oferta = ps.old_normal
            FROM price_swaps ps
            WHERE mp.codigo_interno = ps.codigo_interno 
            AND mp.fecha = ps.fecha;
        """
        
        try:
            print("‚ö° Ejecutando correcci√≥n de precios...")
            
            self.cursor.execute(simple_correction_sql)
            corrected_count = self.cursor.rowcount
            
            print(f"‚úÖ CORRECCI√ìN COMPLETADA:")
            print(f"   üìä Registros corregidos: {corrected_count}")
            
            # Verificar que no quedan precios inv√°lidos
            self.cursor.execute("""
                SELECT COUNT(*) as remaining_invalid
                FROM master_precios 
                WHERE precio_oferta > precio_normal 
                AND precio_oferta IS NOT NULL
                AND precio_normal IS NOT NULL
            """)
            
            remaining = self.cursor.fetchone()['remaining_invalid']
            
            if remaining == 0:
                print(f"   üéâ Verificaci√≥n: 0 precios inv√°lidos restantes")
            else:
                print(f"   ‚ö†Ô∏è Advertencia: {remaining} precios inv√°lidos a√∫n presentes")
            
            self.stats['prices_corrected'] = corrected_count
            
        except Exception as e:
            print(f"‚ùå Error durante correcci√≥n: {e}")
            
            # M√©todo alternativo registro por registro (m√°s lento pero seguro)
            print("üîÑ Intentando m√©todo alternativo...")
            self.correct_prices_one_by_one()
    
    def correct_prices_one_by_one(self):
        """üîÑ Correcci√≥n precio por precio (m√©todo seguro)"""
        print("üîÑ Corrigiendo precios uno por uno...")
        
        # Obtener registros inv√°lidos
        self.cursor.execute("""
            SELECT codigo_interno, fecha, precio_normal, precio_oferta
            FROM master_precios 
            WHERE precio_oferta > precio_normal 
            AND precio_oferta IS NOT NULL
            AND precio_normal IS NOT NULL
            LIMIT 1000
        """)
        
        invalid_records = self.cursor.fetchall()
        corrected = 0
        
        for record in invalid_records:
            try:
                # Intercambiar precios
                self.cursor.execute("""
                    UPDATE master_precios 
                    SET precio_normal = %s, precio_oferta = %s
                    WHERE codigo_interno = %s AND fecha = %s
                """, (
                    record['precio_oferta'],  # nuevo precio_normal
                    record['precio_normal'],  # nuevo precio_oferta  
                    record['codigo_interno'],
                    record['fecha']
                ))
                
                corrected += 1
                
                if corrected % 100 == 0:
                    print(f"   üìä Corregidos: {corrected}/{len(invalid_records)}")
                    
            except Exception as e:
                print(f"   ‚ùå Error corrigiendo {record['codigo_interno']}: {e}")
        
        print(f"‚úÖ Correcci√≥n manual completada: {corrected} registros")
        self.stats['prices_corrected'] = corrected
    
    def add_working_constraints(self):
        """üõ°Ô∏è Agregar constraints que funcionen con datos corregidos"""
        print("\n" + "üõ°Ô∏è" + "="*80 + "üõ°Ô∏è")
        print("üõ°Ô∏è AGREGANDO CONSTRAINTS FUNCIONALES")
        print("üõ°Ô∏è" + "="*80 + "üõ°Ô∏è")
        
        # Primero verificar que no hay precios inv√°lidos
        self.cursor.execute("""
            SELECT COUNT(*) as invalid_count
            FROM master_precios 
            WHERE precio_oferta > precio_normal 
            AND precio_oferta IS NOT NULL
            AND precio_normal IS NOT NULL
        """)
        
        invalid_remaining = self.cursor.fetchone()['invalid_count']
        
        if invalid_remaining > 0:
            print(f"‚ö†Ô∏è A√∫n hay {invalid_remaining} precios inv√°lidos - corrigiendo primero...")
            self.correct_invalid_prices_simple()
        
        # Constraints que pueden funcionar
        constraints = [
            {
                'name': 'chk_precio_oferta_valido',
                'sql': """
                    ALTER TABLE master_precios 
                    ADD CONSTRAINT chk_precio_oferta_valido 
                    CHECK (precio_oferta IS NULL OR precio_oferta <= precio_normal)
                """,
                'description': 'Precio oferta ‚â§ precio normal'
            },
            {
                'name': 'chk_precios_positivos_basico',
                'sql': """
                    ALTER TABLE master_precios 
                    ADD CONSTRAINT chk_precios_positivos_basico 
                    CHECK (precio_normal > 0)
                """,
                'description': 'Precio normal debe ser positivo'
            },
            {
                'name': 'chk_precio_tarjeta_valido',
                'sql': """
                    ALTER TABLE master_precios 
                    ADD CONSTRAINT chk_precio_tarjeta_valido 
                    CHECK (precio_tarjeta IS NULL OR precio_tarjeta <= precio_normal)
                """,
                'description': 'Precio tarjeta ‚â§ precio normal'
            }
        ]
        
        constraints_added = 0
        
        for constraint in constraints:
            try:
                print(f"‚ûï Agregando: {constraint['name']}")
                print(f"   üìù {constraint['description']}")
                
                # Eliminar constraint si existe
                self.cursor.execute(f"ALTER TABLE master_precios DROP CONSTRAINT IF EXISTS {constraint['name']}")
                
                # Agregar constraint
                self.cursor.execute(constraint['sql'])
                
                print(f"   ‚úÖ Constraint agregado exitosamente")
                constraints_added += 1
                
            except Exception as e:
                print(f"   ‚ùå Error: {e}")
                
                # Si falla, mostrar algunos registros que violan el constraint
                if 'violates' in str(e):
                    print("   üîç Verificando registros que violan el constraint...")
                    self.show_violating_records(constraint['name'])
        
        print(f"\nüìä CONSTRAINTS: {constraints_added}/{len(constraints)} agregados")
        self.stats['constraints_added'] = constraints_added
        
        # Crear sistema de logging simplificado
        self.create_simple_price_validation_system()
    
    def show_violating_records(self, constraint_name):
        """üîç Mostrar registros que violan constraints"""
        try:
            if 'oferta_valido' in constraint_name:
                self.cursor.execute("""
                    SELECT codigo_interno, fecha, precio_normal, precio_oferta
                    FROM master_precios 
                    WHERE precio_oferta > precio_normal 
                    AND precio_oferta IS NOT NULL
                    LIMIT 3
                """)
                
            elif 'positivos' in constraint_name:
                self.cursor.execute("""
                    SELECT codigo_interno, fecha, precio_normal
                    FROM master_precios 
                    WHERE precio_normal <= 0
                    LIMIT 3
                """)
                
            elif 'tarjeta_valido' in constraint_name:
                self.cursor.execute("""
                    SELECT codigo_interno, fecha, precio_normal, precio_tarjeta
                    FROM master_precios 
                    WHERE precio_tarjeta > precio_normal 
                    AND precio_tarjeta IS NOT NULL
                    LIMIT 3
                """)
            
            violating = self.cursor.fetchall()
            
            if violating:
                print("   üìä Registros que violan el constraint:")
                for record in violating:
                    print(f"      {dict(record)}")
                    
        except Exception as e:
            print(f"   ‚ùå Error verificando violaciones: {e}")
    
    def create_simple_price_validation_system(self):
        """‚ö° Sistema simplificado de validaci√≥n"""
        print(f"\n‚ö° CREANDO SISTEMA DE VALIDACI√ìN SIMPLIFICADO:")
        
        # Tabla de log simple
        log_table_sql = """
            CREATE TABLE IF NOT EXISTS price_validation_log (
                id SERIAL PRIMARY KEY,
                codigo_interno VARCHAR(100),
                fecha DATE,
                precio_normal INTEGER,
                precio_oferta INTEGER,
                validation_error VARCHAR(100),
                rejected_at TIMESTAMP DEFAULT NOW()
            );
            
            CREATE INDEX IF NOT EXISTS idx_price_validation_log_date 
            ON price_validation_log(rejected_at);
        """
        
        # Funci√≥n de trigger simplificada
        trigger_function_sql = """
            CREATE OR REPLACE FUNCTION validate_price_simple() 
            RETURNS TRIGGER AS $$
            BEGIN
                -- Validar precios b√°sicos
                IF NEW.precio_oferta IS NOT NULL AND NEW.precio_oferta > NEW.precio_normal THEN
                    INSERT INTO price_validation_log (
                        codigo_interno, fecha, precio_normal, precio_oferta, validation_error
                    ) VALUES (
                        NEW.codigo_interno, NEW.fecha, NEW.precio_normal, NEW.precio_oferta, 
                        'precio_oferta_mayor'
                    );
                    
                    RAISE EXCEPTION 'Precio oferta (%) mayor que normal (%). Rechazado.', 
                                  NEW.precio_oferta, NEW.precio_normal;
                END IF;
                
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        """
        
        # Trigger
        trigger_sql = """
            DROP TRIGGER IF EXISTS price_validation_trigger ON master_precios;
            
            CREATE TRIGGER price_validation_trigger
                BEFORE INSERT OR UPDATE ON master_precios
                FOR EACH ROW
                EXECUTE FUNCTION validate_price_simple();
        """
        
        try:
            print("   üìã Creando tabla de log...")
            self.cursor.execute(log_table_sql)
            
            print("   ‚ö° Creando funci√≥n de validaci√≥n...")
            self.cursor.execute(trigger_function_sql)
            
            print("   üîó Creando trigger...")
            self.cursor.execute(trigger_sql)
            
            print("   ‚úÖ Sistema de validaci√≥n activo")
            
        except Exception as e:
            print(f"   ‚ùå Error: {e}")
    
    def test_system_functionality(self):
        """üß™ Probar funcionalidad del sistema"""
        print("\n" + "üß™" + "="*80 + "üß™")
        print("üß™ PROBANDO FUNCIONALIDAD DEL SISTEMA")
        print("üß™" + "="*80 + "üß™")
        
        test_cases = [
            {
                'name': 'Precio v√°lido',
                'data': {
                    'codigo_interno': 'TEST-VALID-001',
                    'fecha': '2025-09-04',
                    'precio_normal': 100000,
                    'precio_oferta': 80000
                },
                'should_pass': True
            },
            {
                'name': 'Precio inv√°lido (oferta > normal)',
                'data': {
                    'codigo_interno': 'TEST-INVALID-001', 
                    'fecha': '2025-09-04',
                    'precio_normal': 50000,
                    'precio_oferta': 75000
                },
                'should_pass': False
            }
        ]
        
        for i, test in enumerate(test_cases, 1):
            print(f"\nüß™ Prueba {i}: {test['name']}")
            
            try:
                # Preparar datos m√≠nimos
                insert_sql = """
                    INSERT INTO master_precios 
                    (codigo_interno, fecha, precio_normal, precio_oferta, timestamp_creacion)
                    VALUES (%(codigo_interno)s, %(fecha)s, %(precio_normal)s, %(precio_oferta)s, NOW())
                """
                
                self.cursor.execute(insert_sql, test['data'])
                
                if test['should_pass']:
                    print(f"   ‚úÖ CORRECTO: Inserci√≥n exitosa")
                    # Limpiar
                    self.cursor.execute(
                        "DELETE FROM master_precios WHERE codigo_interno = %(codigo_interno)s",
                        {'codigo_interno': test['data']['codigo_interno']}
                    )
                else:
                    print(f"   ‚ùå ERROR: Inserci√≥n deber√≠a haber fallado")
                    # Limpiar
                    self.cursor.execute(
                        "DELETE FROM master_precios WHERE codigo_interno = %(codigo_interno)s", 
                        {'codigo_interno': test['data']['codigo_interno']}
                    )
                    
            except Exception as e:
                if not test['should_pass']:
                    print(f"   ‚úÖ CORRECTO: Inserci√≥n rechazada")
                    print(f"      üí¨ {str(e)[:100]}...")
                else:
                    print(f"   ‚ùå ERROR: Inserci√≥n v√°lida rechazada")
                    print(f"      üí¨ {e}")
    
    def generate_final_report(self):
        """üìã Generar reporte final"""
        print("\n" + "üìã" + "="*80 + "üìã")
        print("üìã REPORTE FINAL DE CORRECCI√ìN")
        print("üìã" + "="*80 + "üìã")
        
        # Estad√≠sticas finales
        self.cursor.execute("SELECT COUNT(*) as total FROM master_precios")
        total_prices = self.cursor.fetchone()['total']
        
        self.cursor.execute("""
            SELECT COUNT(*) as valid_prices
            FROM master_precios 
            WHERE precio_oferta IS NULL OR precio_oferta <= precio_normal
        """)
        valid_prices = self.cursor.fetchone()['valid_prices']
        
        success_rate = (valid_prices / total_prices * 100) if total_prices > 0 else 0
        
        report = {
            'correction_timestamp': datetime.now().isoformat(),
            'database_schema': self.real_schema,
            'correction_stats': self.stats,
            'final_stats': {
                'total_prices': total_prices,
                'valid_prices': valid_prices,
                'success_rate': round(success_rate, 2)
            }
        }
        
        # Guardar reporte
        report_file = self.parquet_dir.parent / f"database_correction_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        print(f"üìä ESTAD√çSTICAS FINALES:")
        print(f"   üîç Esquema analizado: {'‚úÖ' if self.stats['schema_analyzed'] else '‚ùå'}")
        print(f"   üì¶ Precios inv√°lidos encontrados: {self.stats['invalid_prices_found']}")
        print(f"   üí∏ Precios corregidos: {self.stats['prices_corrected']}")
        print(f"   üõ°Ô∏è Constraints agregados: {self.stats['constraints_added']}")
        print(f"   üì¶ Registros respaldados: {self.stats['records_backed_up']}")
        print(f"   üìà Tasa de √©xito final: {success_rate:.1f}%")
        print(f"   üìÑ Reporte guardado: {report_file}")
        
        return report
    
    def run_complete_fix(self):
        """üöÄ Ejecutar correcci√≥n completa"""
        print("üîß" + "="*80 + "üîß")
        print("üöÄ EJECUTANDO CORRECCI√ìN COMPLETA DE BASE DE DATOS")
        print("üîß" + "="*80 + "üîß")
        
        steps = [
            ("üîç Analizar Esquema", self.analyze_real_database_schema),
            ("üì¶ Backup a Parquet", self.backup_invalid_prices_to_parquet_simple),
            ("üí∏ Corregir Precios", self.correct_invalid_prices_simple),
            ("üõ°Ô∏è Agregar Constraints", self.add_working_constraints),
            ("üß™ Probar Sistema", self.test_system_functionality),
            ("üìã Reporte Final", self.generate_final_report)
        ]
        
        for step_name, step_func in steps:
            try:
                print(f"\n‚è≥ Ejecutando: {step_name}...")
                step_func()
                print(f"‚úÖ {step_name} completado")
            except Exception as e:
                print(f"‚ùå Error en {step_name}: {e}")
                import traceback
                print(f"üîç Detalle: {traceback.format_exc()}")
        
        print("\nüéâ CORRECCI√ìN COMPLETA FINALIZADA")
        print("\nüõ°Ô∏è BASE DE DATOS CORREGIDA Y PROTEGIDA:")
        print("   ‚úÖ Precios inv√°lidos corregidos")
        print("   üõ°Ô∏è Constraints de validaci√≥n activos") 
        print("   üì¶ Datos inv√°lidos respaldados")
        print("   üìä Sistema de monitoreo funcional")
    
    def close(self):
        """üîö Cerrar conexiones"""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        print("üîö Conexiones cerradas")

def main():
    """üöÄ Funci√≥n principal"""
    print("üîß Iniciando Correcci√≥n Completa de Base de Datos...")
    
    fixer = DatabaseSchemaFixer()
    
    try:
        fixer.run_complete_fix()
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Correcci√≥n interrumpida por el usuario")
    except Exception as e:
        print(f"\n‚ùå Error cr√≠tico durante correcci√≥n: {e}")
        import traceback
        traceback.print_exc()
    finally:
        fixer.close()

if __name__ == "__main__":
    main()